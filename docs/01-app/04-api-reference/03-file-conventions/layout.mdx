---
title: layout.js
description: API reference for the layout.js file.
---

The `layout` file is used to define a layout in your Next.js application. Layouts are **shared** between multiple routes. On navigation, they preserve state, remain interactive, and don't re-render.

You can define a layout by default exporting a React component from a `layout.js` file. The component should accept a `children` prop that will be populated with a child layout (if it exists) or a page during rendering.

```tsx filename="app/dashboard/layout.tsx" switcher
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default function DashboardLayout({ children }) {
  return <section>{children}</section>
}
```

> **Good to know**:
>
> - `.js`, `.jsx`, or `.tsx` file extensions can be used for Layouts.
> - Layouts are [Server Components](https://react.dev/reference/rsc/server-components) by default but can be set to a [Client Component](https://react.dev/reference/rsc/use-client).

## Reference

### Props

#### `children` (required)

Layout components should accept and use a `children` prop. During rendering, `children` will be populated with the route segments the layout is wrapping. This can be a child [`layout.js`](/docs/app/api-reference/file-conventions/layout) (if it exists) or [`page.js`](/docs/app/api-reference/file-conventions/page), but could also be other special files like [`loading.js`](/docs/app/api-reference/file-conventions/loading) or [`error.js`](/docs/app/api-reference/file-conventions/error) when applicable.

#### `params` (optional)

A promise that resolves to an object containing the [dynamic route parameters](/docs/app/building-your-application/routing/dynamic-routes) object from the root segment down to that layout.

```tsx filename="app/dashboard/[team]/layout.tsx" switcher
export default async function Layout({
  params,
}: {
  params: Promise<{ team: string }>
}) {
  const team = (await params).team
}
```

```jsx filename="app/dashboard/[team]/layout.js" switcher
export default async function Layout({ params }) {
  const team = (await params).team
}
```

| Example Route                     | URL            | `params`                           |
| --------------------------------- | -------------- | ---------------------------------- |
| `app/dashboard/[team]/layout.js`  | `/dashboard/1` | `Promise<{ team: '1' }>`           |
| `app/shop/[tag]/[item]/layout.js` | `/shop/1/2`    | `Promise<{ tag: '1', item: '2' }>` |
| `app/blog/[...slug]/layout.js`    | `/blog/1/2`    | `Promise<{ slug: ['1', '2'] }>`    |

- Since the `params` prop is a promise. You must use `async/await` or React's [`use`](https://react.dev/reference/react/use) function to access the values.
  - In version 14 and earlier, `params` was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.

### Root Layouts

The root layout is defined at the top level of the `app` directory and applies to all routes. This layout is **required** and must contain `html` and `body` tags, allowing you to modify the initial HTML returned from the server.

The `app` router **must** include a root `app/layout.js`.

```tsx filename="app/layout.tsx" switcher
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

```jsx filename="app/layout.js" switcher
export default function RootLayout({ children }) {
  return (
    <html>
      <body>{children}</body>
    </html>
  )
}
```

## Examples

### Nesting Layouts

By default, layouts in the folder hierarchy are **nested**, which means they wrap child layouts via their `children` prop. You can nest layouts by adding `layout.js` inside specific route segments (folders).

For example, to create a layout for the `/dashboard` route, add a new `layout.js` file inside the `dashboard` folder:

<Image
  alt="Nested Layout"
  srcLight="/docs/light/nested-layout.png"
  srcDark="/docs/dark/nested-layout.png"
  width="1600"
  height="606"
/>

```tsx filename="app/dashboard/layout.tsx" switcher
export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default function DashboardLayout({ children }) {
  return <section>{children}</section>
}
```

If you were to combine the two layouts above, the root layout (`app/layout.js`) would wrap the dashboard layout (`app/dashboard/layout.js`), which would wrap route segments inside `app/dashboard/*`.

The two layouts would be nested as such:

<Image
  alt="Nested Layouts"
  srcLight="/docs/light/nested-layouts-ui.png"
  srcDark="/docs/dark/nested-layouts-ui.png"
  width="1600"
  height="1026"
/>

### Creating multiple root layouts

You can use [route groups](/docs/app/building-your-application/routing/route-groups) to create multiple root layouts.

Navigating across multiple root layouts will cause a **full page load** (as opposed to a client-side navigation). For example, navigating from `/cart` that uses `app/(shop)/layout.js` to `/blog` that uses `app/(marketing)/layout.js` will cause a full page load.

{/* TODO: Add Diagram */}

### Adding metadata

You should **not** manually add `<head>` tags such as `<title>` and `<meta>` to layouts. Instead, you can use the [Metadata API](/docs/app/building-your-application/optimizing/metadata) which automatically handles advanced requirements such as streaming and de-duplicating `<head>` elements.

```tsx filename="app/dashboard/layout.tsx" switcher
// This metadata will be applied to all pages in /dashboard/*
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: 'Dashboard',
  description: 'Dashboard',
}

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <section>{children}</section>
}
```

```jsx filename="app/dashboard/layout.js" switcher
// This metadata will be applied to all pages in /dashboard/*
export const metadata = {
  title: 'Dashboard',
  description: 'Dashboard',
}

export default function DashboardLayout({ children }) {
  return <section>{children}</section>
}
```

### Fetching and passing data

Layouts are [Server Components](/docs/app/building-your-application/rendering/server-components) by default, so you can fetch data by turning them into `async` functions.

```tsx filename="app/dashboard/layout.tsx" switcher
import { fetchUser } from '@/lib/data'

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  const user = await fetchUser('007')
  return (
    <section>
      <header>
        <h1>Welcome {user.name}/h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default async function DashboardLayout({ children }) {
  const user = await fetchUser('007')

  return (
    <section>
      <header>
        <h1>Welcome {user.name}/h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

However, passing data between a layout and its children is not possible. Instead, you can fetch the same data in a route more than once, and use React's [`cache`](https://react.dev/reference/react/cache) function to dedupe the requests without affecting performance.

```tsx filename="app/lib/data.ts" switcher
import { cache } from 'react'

export const fetchUser = cache(async (userId: string) => {
  const response = await fetch(`https://api.example.com/user/${userId}`)
  const data = await response.json()
  return data.user
})
```

```jsx filename="app/lib/data.js" switcher
import { cache } from 'react'

export const fetchUser = cache(async (userId) => {
  const response = await fetch(`https://api.example.com/user/${userId}`)
  const data = await response.json()
  return data.user
})
```

### Accessing `pathname`

Layouts cannot access `pathname`. This is because layouts are Server Components by default, and [don't rerender during client-side navigation](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering), which could lead to `pathname` becoming stale between navigations. To prevent staleness, Next.js would need to refetch all segments of a route, losing the benefits of caching and increasing the [RSC payload](/docs/app/building-your-application/rendering/server-components#what-is-the-react-server-component-payload-rsc) size on navigation.

Instead, you can extract the logic that depends on pathname into a Client Component and import it into your layouts. Since Client Components rerender (but are not refetched) during navigation, you can use Next.js hooks such as [`usePathname`](https://nextjs.org/docs/app/api-reference/functions/use-pathname) to access the current pathname and prevent staleness.

Create a layout that imports a Client Component:

```tsx filename="app/dashboard/layout.tsx" switcher
import { ClientComponent } from '@/app/ui/ClientComponent'

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <ClientComponent />
      {/* Other Layout UI */}
      <main>{children}</main>
    </>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
import { ClientComponent } from '@/app/ui/ClientComponent'

export default function Layout({ children }) {
  return (
    <>
      <ClientComponent />
      {/* Other Layout UI */}
      <main>{children}</main>
    </>
  )
}
```

Then, call the `usePathname` hook in the Client Component:

```tsx filename="app/ui/ClientComponent.tsx" switcher
'use client'

import { usePathname } from 'next/navigation'

export function ClientComponent() {
  const pathname = usePathname()
  return <div>Current path: {pathname}</div>
}
```

```jsx filename="app/ui/ClientComponent.js" switcher
'use client'

import { usePathname } from 'next/navigation'

export function ClientComponent() {
  const pathname = usePathname()
  return <div>Current path: {pathname}</div>
}
```

### Accessing `searchParams`

Unlike [Pages](/docs/app/api-reference/file-conventions/page), Layout components **do not** receive the `searchParams` prop. This is because a shared layout is [not re-rendered during navigation](/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering) which could lead to stale `searchParams` between navigations.

When using client-side navigation, Next.js automatically only renders the part of the page below the common layout between two routes.

For example, in the following directory structure, `dashboard/layout.tsx` is the common layout for both `/dashboard/settings` and `/dashboard/analytics`:

<Image
  alt="File structure showing a dashboard folder nesting a layout.tsx file, and settings and analytics folders with their own pages"
  srcLight="/docs/light/shared-dashboard-layout.png"
  srcDark="/docs/dark/shared-dashboard-layout.png"
  width="1600"
  height="687"
/>

When navigating from `/dashboard/settings` to `/dashboard/analytics`, `page.tsx` in `/dashboard/analytics` will rerender on the server, while `dashboard/layout.tsx` will **not** rerender because it's a common UI shared between the two routes.

This performance optimization allows navigation between pages that share a layout to be quicker as only the data fetching and rendering for the page has to run, instead of the entire route that could include shared layouts that fetch their own data.

Because `dashboard/layout.tsx` doesn't re-render, the `searchParams` prop in the layout Server Component might become **stale** after navigation.

Instead, use the Page [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) prop.

### Accessing route segments below a layout

Layouts do not have access to the route segments below themselves. To access all route segments, you can use [`useSelectedLayoutSegment`](/docs/app/api-reference/functions/use-selected-layout-segment) or [`useSelectedLayoutSegments`](/docs/app/api-reference/functions/use-selected-layout-segments) in a Client Component.

Create a layout that imports a Client Component:

```tsx filename="app/dashboard/layout.tsx" switcher
import { ClientComponent } from '@/app/ui/ClientComponent'

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <>
      <ClientComponent />
      <main>{children}</main>
    </>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
import { ClientComponent } from '@/app/ui/ClientComponent'

export default function DashboardLayout({ children }) {
  return (
    <>
      <ClientComponent />
      <main>{children}</main>
    </>
  )
}
```

Then, call the `useSelectedLayoutSegment` hook in the Client Component:

```tsx filename="app/ui/ClientComponent.tsx" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export function ClientComponent() {
  const segment = useSelectedLayoutSegment()
  return <div>Current segment: {segment}</div>
}
```

```jsx filename="app/ui/ClientComponent.js" switcher
'use client'

import { useSelectedLayoutSegment } from 'next/navigation'

export function ClientComponent() {
  const segment = useSelectedLayoutSegment()
  return <div>Current segment: {segment}</div>
}
```

### Displaying content based on `params`

Using [dynamic route segments](/docs/app/building-your-application/routing/dynamic-routes), you can display or fetch specific content based on the `params` prop.

```tsx filename="app/dashboard/layout.tsx" switcher
export default async function DashboardLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: Promise<{ team: string }>
}) {
  const { team } = await params

  return (
    <section>
      <header>
        <h1>Welcome to {team}'s Dashboard</h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

```jsx filename="app/dashboard/layout.js" switcher
export default async function DashboardLayout({ children, params }) {
  const { team } = await params

  return (
    <section>
      <header>
        <h1>Welcome to {team}'s Dashboard</h1>
      </header>
      <main>{children}</main>
    </section>
  )
}
```

### Reading `params` in Client Components

To use `params` in a Client Component (which cannot be `async`), you can use React's [`use`](https://react.dev/reference/react/use) function to read the promise:

```tsx filename="app/page.tsx" switcher
'use client'

import { use } from 'react'

export default function Page({
  params,
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = use(params)
}
```

```js filename="app/page.js" switcher
'use client'

import { use } from 'react'

export default function Page({ params }) {
  const { slug } = use(params)
}
```

## Version History

| Version      | Changes                                                                                                          |
| ------------ | ---------------------------------------------------------------------------------------------------------------- |
| `v15.0.0-RC` | `params` is now a promise. A [codemod](/docs/app/building-your-application/upgrading/codemods#150) is available. |
| `v13.0.0`    | `layout` introduced.                                                                                             |
